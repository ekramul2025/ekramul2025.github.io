<!doctype html>
<html lang="bn">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Auth (QR + Encrypted Import/Export)</title>
<style>
  :root{--bg:#0b1220;--card:#071427;--muted:#9aa4b2;--accent:#06b6d4;--danger:#ff5c5c}
  *{box-sizing:border-box}
  body{margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,#00121a,#071429);color:#e6eef6;display:flex;justify-content:center;padding:28px}
  .app{width:980px;max-width:98%}
  header{display:flex;align-items:center;justify-content:space-between;margin-bottom:18px}
  h1{margin:0;font-size:20px}
  .controls{display:flex;gap:8px;align-items:center}
  button.btn{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 12px;border-radius:10px;color:var(--muted);cursor:pointer}
  .primary{background:linear-gradient(90deg,var(--accent),#0ea5a1);color:#001;border:none}
  .list{display:grid;grid-template-columns:repeat(auto-fill,minmax(300px,1fr));gap:12px}
  .card{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));padding:14px;border-radius:12px;display:flex;gap:12px;align-items:center}
  .left{width:72px;height:72px;display:grid;place-items:center;position:relative}
  svg{transform:rotate(-90deg);width:68px;height:68px}
  .otpBlock{flex:1;min-width:0}
  .issuer{font-weight:600;font-size:14px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .account{font-size:13px;color:var(--muted);margin-top:4px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .digits{font-family:ui-monospace,Menlo,monospace;font-size:26px;letter-spacing:6px;margin-top:6px}
  .metaRow{display:flex;align-items:center;gap:8px;margin-top:8px}
  .small{font-size:12px;color:var(--muted)}
  .iconBtn{background:transparent;border:1px solid rgba(255,255,255,0.03);padding:6px;border-radius:8px;color:var(--muted);cursor:pointer;font-size:13px}
  .danger{border-color:rgba(255,92,92,0.15);color:var(--danger)}
  .modalBg{position:fixed;inset:0;background:rgba(2,6,23,0.6);display:grid;place-items:center;z-index:60}
  .modal{width:520px;max-width:96%;background:var(--card);padding:16px;border-radius:12px}
  label{display:block;font-size:13px;color:var(--muted);margin-top:10px}
  input[type="text"], input[type="number"], input[type="password"]{width:100%;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:transparent;color:inherit;font-family:monospace}
  .empty{background:rgba(255,255,255,0.02);padding:20px;border-radius:10px;text-align:center;color:var(--muted)}
  /* QR scanner container */
  #qr-reader { width:100%; max-width:480px; margin:10px auto; }
</style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Auth (QR + Encrypted Import/Export)</h1>
      <div class="controls">
        <button id="importBtn" class="btn">Import (Encrypted)</button>
        <button id="exportBtn" class="btn">Export (Encrypted)</button>
        <button id="scanBtn" class="btn">Scan QR</button>
        <button id="addBtn" class="btn primary">+ Add Account</button>
      </div>
    </header>

    <main>
      <div id="listArea" class="list"></div>
      <div id="empty" class="empty" style="display:none;margin-top:12px">কোনো অ্যাকাউন্ট নেই — Add Account চাপুন বা QR scan করুন।</div>
      <div style="margin-top:12px;font-size:12px;color:var(--muted)">LocalStorage কী: <strong>totp_accounts_v1</strong></div>
    </main>
  </div>

  <div id="modalRoot" style="display:none"></div>

  <!-- html5-qrcode script (CDN) -->
  <script src="https://unpkg.com/html5-qrcode@2.3.8/minified/html5-qrcode.min.js"></script>

<script>
/* ====== CONFIG ====== */
const LS_KEY = "totp_accounts_v1";

/* ====== UTIL: Base32 decode & TOTP ====== */
function base32ToBytes(base32) {
  const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
  let bits = 0, value = 0;
  const output = [];
  base32 = String(base32 || "").toUpperCase().replace(/=+$/, "").replace(/[^A-Z2-7]/g, "");
  for (let i=0;i<base32.length;i++){
    const val = alphabet.indexOf(base32[i]);
    if (val === -1) continue;
    value = (value << 5) | val;
    bits += 5;
    if (bits >= 8) {
      bits -= 8;
      output.push((value >>> bits) & 0xFF);
    }
  }
  return new Uint8Array(output);
}
function counterToBytes(counter) {
  const buf = new ArrayBuffer(8);
  const view = new DataView(buf);
  const hi = Math.floor(counter / 0x100000000);
  const lo = counter >>> 0;
  view.setUint32(0, hi);
  view.setUint32(4, lo);
  return new Uint8Array(buf);
}
function bytesToHex(b){ return Array.from(b).map(x=>x.toString(16).padStart(2,"0")).join(""); }
async function hmacSha1(keyBytes, dataBytes) {
  const cryptoKey = await crypto.subtle.importKey("raw", keyBytes, { name: "HMAC", hash: { name: "SHA-1" } }, false, ["sign"]);
  const sig = await crypto.subtle.sign("HMAC", cryptoKey, dataBytes);
  return new Uint8Array(sig);
}
function truncateToTOTP(hmacBytes, digits=6) {
  const offset = hmacBytes[hmacBytes.length - 1] & 0x0f;
  const p = ( (hmacBytes[offset] & 0x7f) << 24 ) |
            ( (hmacBytes[offset+1] & 0xff) << 16 ) |
            ( (hmacBytes[offset+2] & 0xff) << 8 ) |
            ( (hmacBytes[offset+3] & 0xff) );
  const mod = Math.pow(10, digits);
  return (p % mod).toString().padStart(digits, "0");
}
async function totpForSecret(base32Secret, step=30, digits=6, atTime=null) {
  const keyBytes = base32ToBytes(base32Secret);
  const unix = atTime !== null ? Math.floor(atTime/1000) : Math.floor(Date.now()/1000);
  const counter = Math.floor(unix / step);
  const counterBytes = counterToBytes(counter);
  const hmac = await hmacSha1(keyBytes, counterBytes);
  const otp = truncateToTOTP(hmac, digits);
  return { otp, hmacHex: bytesToHex(hmac), unix, counter };
}

/* ====== Storage helpers ====== */
function loadAccounts(){ try { const r = localStorage.getItem(LS_KEY); return r ? JSON.parse(r) : []; } catch(e){ return []; } }
function saveAccounts(a){ localStorage.setItem(LS_KEY, JSON.stringify(a)); }

/* ====== UI render ====== */
const listArea = document.getElementById("listArea");
const empty = document.getElementById("empty");
function uid(){ return Date.now().toString(36) + Math.random().toString(36).slice(2,8); }
function escapeHtml(s){ return String(s||"").replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;"); }

async function renderList(){
  const accounts = loadAccounts();
  listArea.innerHTML = "";
  if (!accounts.length){ empty.style.display = "block"; return; } else empty.style.display = "none";
  for (const acc of accounts){
    const card = document.createElement("div"); card.className = "card"; card.dataset.id = acc.id;
    card.innerHTML = `
      <div class="left">
        <svg viewBox="0 0 100 100" aria-hidden="true">
          <circle cx="50" cy="50" r="44" stroke="rgba(255,255,255,0.06)" stroke-width="12" fill="none"></circle>
          <circle class="prog" cx="50" cy="50" r="44" stroke="${acc.color||'#06b6d4'}" stroke-width="12" stroke-linecap="round" fill="none" stroke-dasharray="276.460" stroke-dashoffset="276.460"></circle>
        </svg>
        <div style="position:absolute;inset:0;display:grid;place-items:center;font-size:12px" class="secTxt">--</div>
      </div>
      <div class="otpBlock">
        <div class="issuer">${escapeHtml(acc.issuer||'App')}</div>
        <div class="account">${escapeHtml(acc.account||'account')}</div>
        <div class="digits">------</div>
        <div class="metaRow">
          <div class="small">Step: ${acc.step||30}s • Digits: ${acc.digits||6}</div>
          <div style="flex:1"></div>
          <button class="iconBtn copyBtn">Copy</button>
          <button class="iconBtn editBtn">Edit</button>
          <button class="iconBtn danger delBtn">Del</button>
        </div>
      </div>
    `;
    listArea.appendChild(card);
    attachDynamic(card, acc);
  }
}

/* ====== dynamic per-card updates ====== */
const cardAnim = new Map();
function attachDynamic(card, acc){
  const prog = card.querySelector(".prog");
  const secTxt = card.querySelector(".secTxt");
  const digitsEl = card.querySelector(".digits");
  const copyBtn = card.querySelector(".copyBtn");
  const editBtn = card.querySelector(".editBtn");
  const delBtn = card.querySelector(".delBtn");

  let raf = null;
  async function tick(){
    const step = acc.step || 30;
    const unix = Math.floor(Date.now()/1000);
    const rem = step - (unix % step);
    const frac = rem / step;
    const circ = 2 * Math.PI * 44;
    const offset = circ * (1 - frac);
    prog.setAttribute("stroke-dashoffset", offset.toFixed(3));
    secTxt.textContent = rem + "s";
    try {
      const { otp } = await totpForSecret(acc.secret, acc.step||30, acc.digits||6);
      digitsEl.textContent = otp;
    } catch(e){
      digitsEl.textContent = "err";
    }
    raf = requestAnimationFrame(tick);
  }
  if (cardAnim.has(card)) cancelAnimationFrame(cardAnim.get(card));
  cardAnim.set(card, requestAnimationFrame(tick));

  copyBtn.addEventListener("click", async ()=> {
    try { await navigator.clipboard.writeText(digitsEl.textContent||""); copyBtn.textContent="Copied"; setTimeout(()=>copyBtn.textContent="Copy",900); } catch(e){ copyBtn.textContent="Err"; setTimeout(()=>copyBtn.textContent="Copy",900); }
  });
  editBtn.addEventListener("click", ()=> openModal(acc));
  delBtn.addEventListener("click", ()=> {
    if (!confirm(`Delete ${acc.issuer} — ${acc.account}?`)) return;
    const arr = loadAccounts().filter(a=>a.id !== acc.id); saveAccounts(arr); renderList();
  });
}

/* ====== modal for add/edit ====== */
const modalRoot = document.getElementById("modalRoot");
function openModal(existing=null){
  modalRoot.innerHTML = `
    <div class="modalBg">
      <div class="modal">
        <h3>${existing ? "Edit" : "Add"} Account</h3>
        <label>Issuer</label><input id="m_issuer" type="text" value="${existing?escapeHtml(existing.issuer):''}" />
        <label>Account</label><input id="m_account" type="text" value="${existing?escapeHtml(existing.account):''}" />
        <label>Secret (Base32)</label><input id="m_secret" type="text" value="${existing?escapeHtml(existing.secret):''}" />
        <div style="display:flex;gap:8px;margin-top:8px">
          <div style="flex:1"><label>Digits</label><input id="m_digits" type="number" min="6" max="8" value="${existing?escapeHtml(existing.digits):6}" /></div>
          <div style="width:120px"><label>Step (s)</label><input id="m_step" type="number" min="10" max="300" value="${existing?escapeHtml(existing.step):30}" /></div>
        </div>
        <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
          <button class="btn" id="m_cancel">Cancel</button>
          <button class="btn primary" id="m_save">${existing?'Save':'Add'}</button>
        </div>
      </div>
    </div>
  `;
  modalRoot.style.display = "block";
  document.getElementById("m_cancel").onclick = closeModal;
  document.getElementById("m_save").onclick = async ()=>{
    const issuer = document.getElementById("m_issuer").value.trim();
    const account = document.getElementById("m_account").value.trim();
    const secret = document.getElementById("m_secret").value.trim();
    const digits = Math.max(6, Math.min(8, Number(document.getElementById("m_digits").value||6)));
    const step = Math.max(10, Math.min(300, Number(document.getElementById("m_step").value||30)));
    if (!secret){ alert("Secret দরকার"); return; }
    const arr = loadAccounts();
    if (existing){
      const idx = arr.findIndex(a=>a.id===existing.id);
      if (idx !== -1) arr[idx] = {...arr[idx], issuer, account, secret, digits, step};
    } else {
      arr.push({ id: uid(), issuer, account, secret, digits, step, color: pickColor() });
    }
    saveAccounts(arr); closeModal(); renderList();
  };
}
function closeModal(){ modalRoot.style.display="none"; modalRoot.innerHTML=""; }

function pickColor(){
  const palette = ["#06b6d4","#f59e0b","#8b5cf6","#ef4444","#10b981","#3b82f6","#f97316","#7c3aed"];
  return palette[Math.floor(Math.random()*palette.length)];
}

/* ====== QR SCAN: uses html5-qrcode ====== */
document.getElementById("scanBtn").addEventListener("click", openQrScanner);

function openQrScanner(){
  modalRoot.innerHTML = `
    <div class="modalBg">
      <div class="modal" style="max-width:640px">
        <h3>Scan QR (otpauth:// or JSON)</h3>
        <div id="qr-reader"></div>
        <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
          <button class="btn" id="qr_cancel">Close</button>
        </div>
        <div class="small" style="margin-top:8px;color:var(--muted)">Scan QR that encodes an otpauth:// URL (Google Auth style) or a JSON with fields {issuer,account,secret}.</div>
      </div>
    </div>
  `;
  modalRoot.style.display = "block";
  const qrRegionId = "qr-reader";
  const html5QrCode = new Html5Qrcode(qrRegionId);
  const config = { fps: 10, qrbox: { width: 300, height: 300 } };
  html5QrCode.start({ facingMode: "environment" }, config, qrSuccess, qrError).catch(err=>{
    alert("QR start failed: " + err);
    closeQr();
  });

  document.getElementById("qr_cancel").onclick = closeQr;

  function closeQr(){
    html5QrCode.stop().then(()=> {
      html5QrCode.clear();
      closeModal();
    }).catch(()=> { closeModal(); });
  }

  async function qrSuccess(decodedText, decodedResult){
    // decodedText could be otpauth:// or JSON
    try {
      if (decodedText.trim().startsWith("otpauth://")) {
        // parse otpauth URL: otpauth://totp/Issuer:account?secret=ABC&issuer=Issuer&digits=6&period=30
        const u = new URL(decodedText);
        const label = decodeURIComponent(u.pathname.slice(1)); // may be "Issuer:account"
        const q = Object.fromEntries(u.searchParams.entries());
        let issuer = q.issuer || (label.includes(":") ? label.split(":")[0] : label);
        let account = (label.includes(":") ? label.split(":").slice(1).join(":") : label);
        const secret = q.secret || q.key || "";
        const digits = Number(q.digits || 6);
        const step = Number(q.period || q.step || 30);
        if (!secret) throw new Error("No secret in otpauth URL");
        // create account
        const arr = loadAccounts();
        arr.push({ id: uid(), issuer, account, secret, digits, step, color: pickColor() });
        saveAccounts(arr);
        await renderList();
        alert("Added from otpauth QR: " + (issuer||"") + " / " + (account||""));
        closeQr();
      } else {
        // try parse JSON
        const obj = JSON.parse(decodedText);
        if (obj.secret) {
          const arr = loadAccounts();
          arr.push({ id: uid(), issuer: obj.issuer || "QR", account: obj.account || "", secret: obj.secret, digits: obj.digits||6, step: obj.step||30, color: pickColor() });
          saveAccounts(arr);
          await renderList();
          alert("Added from JSON QR");
          closeQr();
        } else {
          throw new Error("QR content unrecognized");
        }
      }
    } catch (err){
      console.error(err);
      alert("Scan parse failed: " + err.message);
    }
  }

  function qrError(err){
    // ignore frequent errors
    // console.log("QR err", err);
  }
}

/* ====== ENCRYPT / DECRYPT helpers (PBKDF2 + AES-GCM) ====== */
function bufToBase64(b){ return btoa(String.fromCharCode(...new Uint8Array(b))); }
function base64ToBuf(s){ const bin = atob(s); const arr = new Uint8Array(bin.length); for (let i=0;i<bin.length;i++) arr[i]=bin.charCodeAt(i); return arr.buffer; }

async function deriveKey(password, salt, iterations=250000, keyLen=256){
  const pwUtf8 = new TextEncoder().encode(password);
  const baseKey = await crypto.subtle.importKey("raw", pwUtf8, {name:"PBKDF2"}, false, ["deriveKey"]);
  const key = await crypto.subtle.deriveKey({
    name: "PBKDF2", salt: salt, iterations: iterations, hash: "SHA-256"
  }, baseKey, { name: "AES-GCM", length: keyLen }, false, ["encrypt","decrypt"]);
  return key;
}

async function encryptJSON(obj, password){
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const key = await deriveKey(password, salt.buffer);
  const plain = new TextEncoder().encode(JSON.stringify(obj));
  const cipher = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, plain);
  return {
    version: 1,
    salt: bufToBase64(salt),
    iv: bufToBase64(iv),
    ciphertext: bufToBase64(cipher)
  };
}

async function decryptJSON(encObj, password){
  const salt = base64ToBuf(encObj.salt);
  const iv = base64ToBuf(encObj.iv);
  const cipher = base64ToBuf(encObj.ciphertext);
  const key = await deriveKey(password, salt);
  const plain = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, cipher);
  const text = new TextDecoder().decode(plain);
  return JSON.parse(text);
}

/* ====== Import (encrypted) ====== */
document.getElementById("importBtn").addEventListener("click", ()=>{
  const inp = document.createElement("input"); inp.type="file"; inp.accept="application/json";
  inp.onchange = async (e) => {
    const f = e.target.files[0]; if (!f) return;
    const reader = new FileReader();
    reader.onload = async (ev) => {
      try {
        const raw = JSON.parse(ev.target.result);
        // ask password
        const pw = prompt("Enter master password to decrypt import file:");
        if (pw === null) return;
        const obj = await decryptJSON(raw, pw);
        if (!Array.isArray(obj)) throw new Error("Decrypted content invalid (expected array)");
        // merge (by id)
        const existing = loadAccounts();
        const map = new Map(existing.map(x=>[x.id,x]));
        for (const it of obj) map.set(it.id || uid(), it);
        const merged = Array.from(map.values());
        saveAccounts(merged); renderList();
        alert("Import successful: " + obj.length + " accounts");
      } catch (err) {
        alert("Import failed: " + (err.message || err));
      }
    };
    reader.readAsText(f);
  };
  inp.click();
});

/* ====== Export (encrypted) ====== */
document.getElementById("exportBtn").addEventListener("click", async ()=>{
  const arr = loadAccounts();
  if (!arr.length){ alert("No accounts to export"); return; }
  const pw = prompt("Enter master password to encrypt export file (you will need same password to import):");
  if (!pw) return;
  try {
    const enc = await encryptJSON(arr, pw);
    const blob = new Blob([JSON.stringify(enc, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url; a.download = "totp_accounts_encrypted.json"; document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
    alert("Exported encrypted file — keep your master password safe.");
  } catch (err) {
    alert("Export failed: " + err.message);
  }
});

/* ====== Add button ====== */
document.getElementById("addBtn").addEventListener("click", ()=> openModal(null));

/* ====== Demo init & render ====== */
(function initDemo(){
  const arr = loadAccounts();
  if (arr.length === 0){
    arr.push({ id: uid(), issuer: "DemoApp", account: "user@example.com", secret: "JBSWY3DPEHPK3PXP", digits:6, step:30, color: pickColor() });
    saveAccounts(arr);
  }
})();
renderList();

</script>
</body>
</html>